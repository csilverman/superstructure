@mixin small() {
   @media screen and (min-width: $small) {
      @content;
   }
}

@mixin medium() {
    @media screen and (min-width: $medium) {
        @content;
    }
}

@mixin large() {
    @media screen and (min-width: $large) {
        @content;
    }
}

@mixin links ($link, $visited, $hover, $active) {
    & {
        color: $link;

        &:visited {
            color: $visited;
        }
        &:hover,
        &:visited:hover {
            color: $hover;
        }
        &:active, &:focus {
            color: $active;
        }
    }
}

@mixin breakout($but-only-after) {
    @media screen and (min-width: $but-only-after) {
		width: 100vw;
		position: relative;
		left: 50%;
		right: 50%;
		margin-left: -50vw;
		margin-right: -50vw;
		max-width: none;	
	}
}



@mixin font($font, $style:regular) {
	
	//	Look up the specified font in the main font database
	//	and get its map
	
	$fontmap: map-get($font-styles, $font);
	font-family: map-get($fontmap, 'font-family');
	$all-css: map-get($fontmap, $style);
	
	//  checking for "use" needs to happen down here.
	//  iterate over all-css
	//  if it hits "use"
	
  @each $key, $value in $all-css {
    @if $key == 'use' {
      //  the value references the other map we need
    	$other-css: map-get($fontmap, $value);
    	$all-css: map-merge($all-css, $other-css);
    	//  merge it into the map of current CSS we already have
//    	@include css($combined-css);
    }
    @else {
//    	@include css($all-css);
    }
  }	
	@include css($all-css);
}


@mixin css($rules) {
	/*
	
	
	*/
	
  //  This is the main map parser.
  //  strategy: start with the first row, and grab the first column
  //  then move to the second row and grab the first column, etc

  $loop: length($breakpoints);

  @for $i from 1 through $loop {
    /*  For a style declaration, font-size: (1em, 0.9em, 0.8em), the first value
        is the base value. It shouldn't be wrapped in a media query. So if
        we're on 1, we know that we don't wrap it in a media query.
    */
    @if $i == 1 {

      @each $key, $value in $rules {
        //  get the list (the value)
        //  and then loop, ignoring all values but the ith value
        $count: 0;

        @each $list-item in $value {
          $count: $count + 1;

          @if $count == $i {
            //  this is the right one

            @if $key != 'use' {
              #{$key}: nth($value, $count);
            }
          }
        }
      }
    }
    @else {
      /*  This is where it gets a little tricky. $i has progressed past 1,
          which means we're past the base styling and should be wrapping any
          additional values in media queries. However, we're also using $i
          to determine which breakpoint we should use.
          
          If we grabbed the $ith value in the breakpoints map, we'd have already
          skipped past the first breakpoint. If our breakpoints are small,
          medium, and large, the resulting CSS would have styling for base
          values (no media query), and then CSS wrapped in a media query for
          the medium breakpoint. But what happened to the small breakpoint?
          
          So we have to cheat a little. We're still using $i to determine which
          value in a series of styles we should use, but when we use $i to refer to
          a breakpoint, we decrement it. So say $i is 2. We're grabbing the second
          value in the list of, say, font-sizes. However, we need an additional
          variable - something set to $i-1 - to get the appropriate breakpoint,
          which should be "small". Let's call that $j.
          (I think the best way to do this would be to start with 0 instead of 1;
          but Sass doesn't allow referring to the 0th element of a list of
          values.)
      */
      $j: $i - 1;
    $current-breakpoint: get-map-value-by-index($breakpoints, $j);

    @media screen and (min-width: $current-breakpoint) {
      @each $key, $value in $rules {
        //  get the list (the value)
        //  and then loop, ignoring all values but the ith value
        $count: 0;

        @each $list-item in $value {
          $count: $count + 1;

          @if $count == $i {
            //  this is the right one
            #{$key}: nth($value, $count);
          }
        }
      }
    }
  }
 }  
}